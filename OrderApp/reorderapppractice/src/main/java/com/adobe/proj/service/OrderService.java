package com.adobe.proj.service;

import java.util.List;
import java.util.Optional;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import org.hibernate.AnnotationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.adobe.proj.dao.OrderDao;
import com.adobe.proj.dao.ProductDao;
import com.adobe.proj.entity.Item;
import com.adobe.proj.entity.Order;
import com.adobe.proj.entity.Product;

import jakarta.transaction.Transactional;

@Service
public class OrderService {
	
	// wires implementation class for this interface, generated by data JPA 
	@Autowired
	private ProductDao productDao; // the repository class which is an interface will be wired here, and what is the class is the class generated by data jpa, and since interface alone cannot be wired so this jpa created class is wired here.
	
	Lock lock = new ReentrantLock();// another way to handle concurrency apart from versioning not recommended.
	
	@Transactional  // using version way for getting concurrency
	public void modifyProduct() {
//		try {
//			lock.tryLock();
		Product p=productDao.findById(3).get();
		p.setQuantity(p.getQuantity()-13);
		System.out.println(p); // without {} fro the versioning way
//		}
//		finally {
//			lock.unlock(); // this i handling at the application level using lock. at the jpa level handling using the versioning.
//		}
	}
	
	/* 
	 {
	 	"customer": {"email", "a@adobe.com"},
	 	"items": [
	 		{"product": {"id": 4},"quantity": 3},
	 		{"product": {"id": 1},"quantity": 2}
	 	]
	 }
	 
	 In orders-> oid->auto not required, order_date->system generated,  total->computation So these all are not needed to be passed;
	 Cutomer_fk is required to be passsed
	 then next items is a collection [] to indicate it is a collection.
	 now for each item > itmeId not required as autincrement, pass the product. Product is an object so first pass the primary key. 
	 then pass the quantity, amount we will compute don; pass the amount.
	 so not passing complete information. just pass product ids and how much you want to purchase,
	 
	*/
	
	@Autowired
	private OrderDao orderDao;
	
	
	
	@Transactional  //what it does is if no exception occurs here , it commits. If any line throws exception it is going to rollback. I don't need to write any logic. Decarative transaction suppport is coming out of the box in spring just put @Transactional annotation which is AOP
	public Order placeOrder(Order o) {
		double total=0.0; // to calculate here
		List<Item> items= o.getItems();
		
		System.out.println("Now traversing for each items !!!");
		for (Item i:items) {
			
			Product p= productDao.findById(i.getProduct().getId()).get(); //now this product will have complete information. Name id, qty everything will be present;
			// above line we are pulling directly from backend which was already in Db and putting it ino PErsistence context. so dirty checking makes sense here.
			// where as order still coming from the application. we haven't made any ORM related  methods.
			if ( (p.getQuantity() - i.getQuantity() )<=0) {
				System.out.println("AKhil Exceptio is thrown not enough quantity");
				throw new AnnotationException("Product " +p.getName()+" not is the stocks"); // this will rolllback whole operation as there is no item in stock
			// in code throw new IllegalAnnotationException
			}
			p.setQuantity(p.getQuantity()-i.getQuantity() );// Dirty checking -->update SQL . Within Transactional code if a component becomes dirty. ORM is going to flush new state to the backend. No need to even call SQL
			i.setAmount(p.getPrice()* i.getQuantity());
			total+=i.getAmount();
		}
		o.setTotal(total);
		return orderDao.save(o); // cascade saves items also. Meaning saving an porder saves the itmes also. here because of dirty checking updating of product is also happening here.
		
	}
	
	 //commeting out to demonstrate the lazy fetching exception & open session in view design pattern
	public List<Order> getOrders(){
		return orderDao.findAll();
	}
	
//	// to demonstrate open session in view design pattern
//	public List<Order> getOrders(){
//		List<Order> orders= orderDao.findAll();
//		System.out.println("Has items been fetched");
//		return orders;
//	}
		// this just got the orders when it is returning the orders // actually items has not been fetched here at this point of time.
		// so only when client it need the items at that time point of time it uses the connection to get the items. but in standalone that is not possible so it throws lazy initaialisation exception
//		Hibernate: 
//		    select
//		        o1_0.oid,
//		        o1_0.customer_fk,
//		        o1_0.order_date,
//		        o1_0.total 
//		    from
//		        orders o1_0
//		Hibernate: 
//		    select
//		        c1_0.email,
//		        c1_0.first_name,
//		        c1_0.last_name 
//		    from
//		        customers c1_0 
//		    where
//		        c1_0.email=?
//		Hibernate: 
//		    select
//		        c1_0.email,
//		        c1_0.first_name,
//		        c1_0.last_name 
//		    from
//		        customers c1_0 
//		    where
//		        c1_0.email=?
//		Has items been fetched
		// No items fetched
	
	
	//to demonstrate the lazy fetching exception
//	public List<Order> getOrders(){
//		List<Order>orders= orderDao.findAll();// at this point only select * from orders is happening. Items are not fetched here. because of lazy fetching
//		for(Order o: orders) {
//			List<Item> items= o.getItems();// Now connects to item table fetches. successfully item fetched
//		}
//		return null;
//	}
	
	public Product insertProduct(Product p) {
		return  productDao.save(p);
	}
	
	public List<Product> getByRange(double low, double high){
		return productDao.getByRange(low, high);
	}
	
	// without exception
//	@Transactional
//	public Product updatePrice(int id, double price) {
//		 productDao.updateProduct(id, price);
//		 return this.getProductById(id); 
//	}
	@Transactional
	public Product updatePrice(int id, double price) throws NotFoundException {
		 productDao.updateProduct(id, price);
		 return this.getProductById(id); 
	}
	
	
	
	public List<Product> getProducts(){
		return productDao.findAll();
	}
	
	// this is the code without exception handling
//	public Product getProductById(int id) {
//		Optional<Product> opt= productDao.findById(id);
//		if(opt.isPresent()) {
//			return opt.get();
//		}
//		else {
//			return null;
//		}
//	}
	
	// with exceptional Handling
	
	public Product getProductById(int id) throws NotFoundException {
		Optional<Product> opt= productDao.findById(id);
		if(opt.isPresent()) {
			return opt.get();
		}
		else {
			throw new NotFoundException("Product with id " + id+ " Not found");
		}
	}
	

}
